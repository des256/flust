# flust

Flutter with Rust WASM library FFIed into a web app - experiment.

## General Idea

We want to call Rust functions from within a Flutter project with as little hassle as possible. The main use case for this is image processing for web applications. The Flutter app forms the main application, and whenever an image needs to be processed, it is sent to optimized Rust code (compiled into a WASM module).

The main project is a Flutter project that outputs exclusively to web. Inside this project is a directory `/rustlib` that hosts a Rust project, as well as a corresponding Dart package with bindings. We want to use the power of `wasm_bindgen`, but without having to add the complexity of bundler ecosystems like `wasm_pack` or `webpack`.

## The Rust Project

The Rust project represents a library that compiles to WASM (`wasm32-unknown-unknown`). The corresponding `cargo.toml` looks like this:

```
[package]
name = "rustlib"
version = "0.1.0"
authors = ["Desmond Germans <desmond@germansmedia.nl>"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[profile.release]
lto = true
opt-level = 's'

[dependencies]
wasm-bindgen = "0.2.79"
```

The crate type should be `"cdylib"` as dynamic library compatible with WASM. For the release build, also enable `lto` and set `opt-level` to size (`'s'`). We're using `wasm-bindgen` to generate the complete JS/WASM interop as a JS module.

The Rust code looks like this:

```
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn do_stuff(things: Vec<u8>) -> String {
    format!("There are {} things.",things.len())
}
```

Note that this function uses Rust concepts, like `Vec<u8>` and `String`. The JS/WASM interop takes care of marshalling this over to JS and allowing Dart to access it properly.

The compilation goes like this (`/rustlib/build.sh`):

```
cargo build --release --target wasm32-unknown-unknown
wasm-bindgen --out-dir pkg --no-typescript --target web target/wasm32-unknown-unknown/release/rustlib.wasm
```

The resulting generated files in `/rustlib/pkg` are also copied into the main Flutter project `/web` directory, so they can be accessed locally from `index.html`.

## The `rustlib` Dart Package

Together with the Rust project is a Dart package that natively accesses the JS bindings. The main file there is `/rustlib/lib/rustlib.dart`:

```
@JS()
library rustlib;
import "package:js/js.dart";
import "dart:typed_data";

@JS("do_stuff")
external String doStuff(Uint8List things);
```

The `@JS()` additions connect the Dart declarations to similar declarations in the corresponding JS module. The Rust `do_stuff` function as generated by `wasm_bindgen` is reformulated here as Dart function `doStuff` with roughly the same parameters and return values. A Rust `Vec<u8>` translates to a Dart `Uint8List`, and the Rust `String` translate to a Dart `String`.

## The Flutter Project

Back to the main Flutter app. Essentially, the Rust library can now be imported by adding the local Dart package `rustlib` to `pubspec.yaml`:

```
dependencies:
  rustlib:
    path: ./rustlib
```

Now the only thing left to do, is to load the WASM module into `index.html`, by adding the following `<script>` tag to `index.html`:

```
<script type="module">
  import init,{ do_stuff } from "./rustlib.js";
  await init();
  window.do_stuff = do_stuff;
</script>
```

Finally, we can just import the Rust library into Flutter, like so:

```
import 'package:rustlib/rustlib.dart';
```

This is further shown in `/lib/main.dart`.

## Future Work

### Too Many Binding Sets

This way of accessing Rust unfortunately requires three places to manually define bindings:

- In the Rust code itself. This is logical.
- In the `rustlib` Dart package.
- In the `index.html` file inside the `/web` directory.

This is okay for small Flutter/Rust interops, but it would be good if these steps could be automated.

### Extend to Other Platforms

This currently only works for web. A next version of this project should also include all other supported Flutter platforms unambiguously.
